#!/bin/bash

# JNode Miner Management Script
SCRIPT_PATH="$(readlink -f "$0")"
WORKING_DIR="$(cd "$(dirname "$SCRIPT_PATH")/.." && pwd)"
DATA_DIR="$HOME/data"

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# 日志函数
log_info() {
	echo -e "${GREEN}[INFO]${NC} $(date '+%Y-%m-%d %H:%M:%S') - $1"
}

log_warn() {
	echo -e "${YELLOW}[WARN]${NC} $(date '+%Y-%m-%d %H:%M:%S') - $1"
}

log_error() {
	echo -e "${RED}[ERROR]${NC} $(date '+%Y-%m-%d %H:%M:%S') - $1"
}

# 显示用法
show_usage() {
	echo "JNode Miner Management Script"
	echo "用法: $0 {init|start|stop|watch|backup|console|status|help}"
	echo ""
	echo "命令说明:"
	echo "  init     初始化JNode环境"
	echo "  start    启动JNode节点"
	echo "  stop     停止JNode节点"
	echo "  watch    监控节点状态"
	echo "  backup   备份节点关键数据"
	echo "  console  进入节点控制台"
	echo "  status   查看节点状态"
	echo "  cleanup  清理节点废旧容器"
	echo "  help     显示此帮助信息"
	echo ""
	echo "示例:"
	echo "  $0 init     # 初始化节点"
	echo "  $0 start    # 启动节点"
	echo "  $0 watch    # 监控节点"
}

# 初始化节点
init_node() {
	log_info "开始初始化JNode节点..."

	## init_jnode.sh

	# 检查数据目录是否存在
	if [ -e "$DATA_DIR/mainnet" ]; then
		echo "警告: 区块链数据目录 $DATA_DIR/mainnet 已存在！"
		echo "重新初始化可能会破坏现有数据。"

		read -p "是否继续重新初始化？(y/N): " confirm

		if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
			log_info "用户取消初始化操作。"
			return 1
		fi
	fi

	echo "进入docker环境"
	sudo docker run --rm -it --name jouleverse-init -v ${WORKING_DIR}:/j -v ${DATA_DIR}:/data ubuntu:20.04 /bin/bash -c 'exec /j/scripts/miner_init.sh'
	echo "docker已退出"
	echo "节点初始化完成"
}

# 启动节点
start_node() {
	log_info "启动JNode节点..."

	## start_jnode.sh

	## 先检查容器是否正在运行
	CONTAINER_NAME="jouleverse-geth"

	if sudo docker ps --format "{{.Names}}" | grep -q "^${CONTAINER_NAME}$"; then
		echo "错误: jouleverse-geth 节点正在运行中!"
		echo "请先手动停止节点，使用以下命令:"
		echo "$0 stop"
		exit 1
	fi

	read -s -p "请输入Clef加密密码：" CLEF_PWD
	echo

	# 创建临时文件（使用mktemp）
	TEMP_PWD_FILE=$(mktemp ${DATA_DIR}/clef_password_XXXXXX)
	chmod 600 "$TEMP_PWD_FILE"

	# 写入密码
	echo "$CLEF_PWD" > "$TEMP_PWD_FILE"

	# 清理函数
	cleanup() {
		rm -f "$TEMP_PWD_FILE" 2>/dev/null || true
		echo "临时文件已清理"
	}

	# 设置trap
	trap cleanup EXIT INT TERM

	# 设置环境变量传递文件名
	export CLEF_PASSWORD_FILE=$(basename $TEMP_PWD_FILE)

	# 启动docker，挂载临时文件
	cd $WORKING_DIR
	sudo -E docker-compose -f docker-compose-miner.yml up -d

	# 等待clef读取密码
	echo "等待clef读取密码..."
	sleep 3

	# 密码读取后，脚本退出时会自动清理临时文件
	unset CLEF_PWD
	echo "节点启动完成"
}

# 停止节点
stop_node() {
	log_info "停止JNode节点..."

	## stop_jnode.sh
	sudo docker exec jouleverse-geth pkill -SIGTERM geth
	sudo docker exec jouleverse-clef pkill -SIGTERM clef
}

# 监控节点
watch_node() {
	log_info "开始监控JNode节点..."

	## jnode_wath.sh
	cd $WORKING_DIR
	sudo docker-compose -f docker-compose-miner.yml logs --tail 10 -f
}

# 备份节点
backup_node() {
	log_info "开始备份JNode节点关键数据..."

	## jnode_backup.sh
	BACKUPDIR=$HOME/jnode-backup-`date +'%Y%m%d-%s'`

	mkdir -p $BACKUPDIR

	echo 备份nodekey...
	sudo cp ${DATA_DIR}/mainnet/geth/nodekey $BACKUPDIR/

	echo 备份keystore...
	sudo cp ${DATA_DIR}/mainnet/keystore/mainnet.keystore $BACKUPDIR/

	echo  备份clef masterseed.json...
	sudo cp ${DATA_DIR}/clef/masterseed.json $BACKUPDIR/

	echo 完成！
}

# 节点控制台
node_console() {
	log_info "进入JNode节点控制台..."

	## jnode_console.sh
	local command="$*"

	if [ -z "$command" ]; then
		# 如果没有参数，进入交互模式
		sudo docker exec -it jouleverse-geth /j/bin/geth attach /data/mainnet/geth.ipc
	else
		# 如果有参数，执行命令
		sudo docker exec -it jouleverse-geth /j/bin/geth --exec "$command" attach /data/mainnet/geth.ipc
	fi
}

# 显示节点状态
show_status() {
	log_info "查看JNode节点状态..."

	sudo docker ps
}

# 清理节点废旧容器
cleanup_node() {
	log_info "清理JNode节点废旧容器..."

	sudo docker container prune
}

# 主函数
main() {
	# 检查参数
	if [[ $# -eq 0 ]]; then
		show_usage
		exit 1
	fi

	COMMAND="$1"

	# 移除第一个参数（命令本身）
	shift

	case "$COMMAND" in
		init)
			init_node
			;;
		start)
			start_node
			;;
		stop)
			stop_node
			;;
		watch)
			watch_node
			;;
		backup)
			backup_node
			;;
		console)
			# 将剩余参数传递给 node_console 函数
			node_console "$@"
			;;
		status)
			show_status
			;;
		cleanup)
			cleanup_node
			;;
		help|--help|-h)
			show_usage
			;;
		*)
			log_error "未知命令: $COMMAND"
			show_usage
			exit 1
			;;
	esac
}

# 运行主函数
main "$@"
